load(
    "@rules_haskell//haskell:defs.bzl",
    "haskell_library",
    "haskell_test",
)

# Note cat-tokens
#
# This is a script to concatenate tokens after CPP preprocessing.
#
# On OSX we used to rely on cpphs to concatenate tokens in
# definitions like
#
# define GET_FIELD(name, hs_rettype, c_rettype) \
#   get/**/name/**/Field :: Coercible o (J a) => o -> JFieldID -> IO hs_rettype;
#
# The C preprocessor in OSX would otherwise replace the
# comments with whitespaces.
#
# Using cpphs, however, required a couple of hacks to workaround
# https://github.com/haskell/cabal/issues/4278
# https://gitlab.haskell.org/ghc/ghc/-/issues/17185
#
# And moreover, when using rules_haskell, ghc passes response files to cpphs,
# which are unsupported.
# https://github.com/tweag/rules_haskell/pull/836
#
# Therefore, we currently resolve concatenation with a custom
# preprocessor to avoid the pile of hacks. The concatenator operator is ####.
#
# define GET_FIELD(name, hs_rettype, c_rettype) \
#   get####name####Field :: Coercible o (J a) => o -> JFieldID -> IO hs_rettype;
#
genrule(
    name = "cat-tokens-sh",
    srcs = [],
    outs = ["cat-tokens.sh"],
    cmd = """
cat > $@ <<END
#!/bin/sh
( echo "{-# LINE 1 \\"\\$$1\\" #-}" ; $(location @sed//:bin) 's/####//g' \\$$2) > \\$$3
exit \\$$?
END
    """,
    executable = 1,
    tools = ["@sed//:bin"],
)

# rule generated from jni/jni.cabal by gazelle_cabal
haskell_library(
    name = "jni",
    srcs = [
        "src/common/Foreign/JNI.hs",
        "src/common/Foreign/JNI/Internal.hs",
        "src/common/Foreign/JNI/Internal/BackgroundWorker.hs",
        "src/common/Foreign/JNI/Internal/RWLock.hs",
        "src/common/Foreign/JNI/NativeMethod.hsc",
        "src/common/Foreign/JNI/String.hs",
        "src/common/Foreign/JNI/Types.hs",
        "src/common/Foreign/JNI/Unsafe.hs",
        "src/common/Foreign/JNI/Unsafe/Internal.hs",
        "src/common/Foreign/JNI/Unsafe/Internal/Introspection.hs",
        "src/linear-types/Foreign/JNI/Safe.hs",
        "src/linear-types/Foreign/JNI/Types/Safe.hs",
    ],
    extra_srcs = ["//jni:cat-tokens-sh"],
    # keep
    ghcopts = [
        "-DVERSION_jni=\"0.8.0\"",
        "-F",
        "-pgmF$(location cat-tokens-sh)",
    ],
    # keep
    tools = ["@sed//:bin"],
    version = "0.8.0",
    visibility = ["//visibility:public"],
    deps = [
        "@openjdk//:lib",
        "@stackage//:async",
        "@stackage//:base",
        "@stackage//:bytestring",
        "@stackage//:choice",
        "@stackage//:constraints",
        "@stackage//:containers",
        "@stackage//:deepseq",
        "@stackage//:inline-c",
        "@stackage//:linear-base",
        "@stackage//:singletons-base",
        "@stackage//:stm",
        "@stackage//:text",
    ],
)

# rule generated from jni/jni.cabal by gazelle_cabal
haskell_test(
    name = "spec",
    timeout = "short",
    srcs = [
        "tests/Foreign/JNISpec.hs",
        "tests/Main.hs",
        "tests/Spec.hs",
    ],
    # keep
    extra_srcs = ["@openjdk//:rpath"],
    ghcopts = [
        "-DVERSION_jni=\"0.8.0\"",
        "-threaded",
        "-lpthread",
        "-DHSPEC_DISCOVER_HSPEC_DISCOVER_PATH=$(location @stackage-exe//hspec-discover)",
        "-optl-Wl,@$(location @openjdk//:rpath)",  # keep
    ],
    main_file = "tests/Main.hs",
    tools = ["@stackage-exe//hspec-discover"],
    version = "0.8.0",
    visibility = ["//visibility:public"],
    deps = [
        ":jni",
        "@stackage//:base",
        "@stackage//:hspec",
        "@stackage//:singletons-base",
    ],
)
